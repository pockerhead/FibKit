//
//  SwiftUIWrapperUIKitContainer.swift
//  FormView
//
//  Created artem on 17.11.2020.
//  Copyright ï¿½ 2020 DIT Moscow. All rights reserved.
//
//  Template generated by Balashov Artem @pockerhead
//

import SwiftUI
import UIKit
import IQKeyboardManagerSwift

public class SwiftUIWrapperContainer<Content>:
    SqueezeView,
    StickyHeaderView,
    FibViewHeader,
    CollectionViewReusableView,
    UIGestureRecognizerDelegate,
    SwipeControlledView,
    FormViewAppearable where Content: View {
    
    var hosting = UIHostingController<SwiftUIWrapperView<Content>>(rootView: SwiftUIWrapperView())
    var hostingView: UIView {
        hosting.view
    }
    
    
    var wrapperSize: SwiftUIWrapper<Content>.Size?
    weak var swiftUIWrapperModel: SwiftUIWrapper<Content>?

    
    private var disabledSafeAreaInsets: DisabledSafeAreaInsets = [.bottom]

    var needConstraintLayout = false
    var hostingViewConstraintLayouted = false
    
    lazy var swipeCoordinator = SwiftUIWrapperSwipeCoordinator(wrapper: self)
    var _needUserInteraction: Bool = false
    public override var needUserInteraction: Bool { _needUserInteraction }
    public var haveSwipeAction: Bool { swipeCoordinator.haveSwipeAction }
    public var isSwipeOpen: Bool { swipeCoordinator.isSwipeOpen }

    private var onAppearClosure: ((UIView) -> Void)?
    private var onDissappearClosure: ((UIView) -> Void)?
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        layer.rasterizationScale = UIScreen.main.scale
        clipsToBounds = false
        layer.masksToBounds = false
        insetsLayoutMarginsFromSafeArea = false
        preservesSuperviewLayoutMargins = false
        swipeCoordinator.configureUI()
        let notification = NSNotification.Name("startSwipeOnSwiftUIWrapper")
        NotificationCenter.default.addObserver(self,
                                               selector: #selector(receiveSwipe(_:)),
                                               name: notification,
                                               object: nil)
        configureUI()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc func receiveSwipe(_ notification: Notification) {
        guard let ref = notification.userInfo?["swipeViewRef"] as? UIView else { return }
        guard ref !== self else { return }
        guard haveSwipeAction else { return }
        swipeCoordinator.animateSwipe(isOpen: false, swipeWidth: swipeCoordinator.rightSwipeHostingViewWidth)
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
    }
    
    public func prepareForReuse() {
        swipeCoordinator.prepareForReuse()
        backgroundColor = .clear
    }
    
    public override func layoutSubviews() {
        UIView.performWithoutAnimation {
            super.layoutSubviews()
            hostingView.backgroundColor = .clear
            self.hostingView.frame.size.width = self.bounds.size.width
            self.hostingView.frame.size.height = self.bounds.size.height
            self.hostingView.frame.origin.y = self.bounds.origin.y
            if !isSwipeOpen {
                self.hostingView.frame.origin.x = self.bounds.origin.x
                self.hostingView.layer.cornerRadius = 0
            }
            if haveSwipeAction, let swipeWidth = swipeCoordinator.rightSwipeHostingViewWidth {
                swipeCoordinator.rightSwipeHostingView.frame = .init(x: bounds.maxX - swipeWidth, y: 0, width: swipeWidth, height: bounds.height)
            }
            if haveSwipeAction, let swipeWidth = swipeCoordinator.leftSwipeHostingViewWidth {
                swipeCoordinator.leftSwipeHostingView.frame = .init(x: 0, y: 0, width: swipeWidth, height: bounds.height)
            }
        }
        if isSwipeOpen, !isAnimating {
            swipeCoordinator.animateSwipe(isOpen: false, swipeWidth: swipeCoordinator.rightSwipeHostingViewWidth)
        }
    }
    
    private func setGreatestSafeAreaInsets() {
        let windowSafeAreaInsets = (UIApplication.shared.delegate)?.window??.safeAreaInsets
        let topVCViewSafeAreaInsets = UIApplication.topViewController()?.view.safeAreaInsets
        if disabledSafeAreaInsets.contains(.top) {
            if (windowSafeAreaInsets?.top ?? 0) > (topVCViewSafeAreaInsets?.top ?? 0) {
                hosting.additionalSafeAreaInsets.top = -(windowSafeAreaInsets?.top ?? 0)
            } else {
                hosting.additionalSafeAreaInsets.top = -(topVCViewSafeAreaInsets?.top ?? 0)
            }
        } else {
            hosting.additionalSafeAreaInsets.top = .zero
        }
        if disabledSafeAreaInsets.contains(.bottom) {
            if (windowSafeAreaInsets?.bottom ?? 0) > (topVCViewSafeAreaInsets?.bottom ?? 0) {
                hosting.additionalSafeAreaInsets.bottom = -(windowSafeAreaInsets?.bottom ?? 0)
            } else {
                hosting.additionalSafeAreaInsets.bottom = -((topVCViewSafeAreaInsets?.bottom ?? 0) + (windowSafeAreaInsets?.bottom ?? 0))
            }
        } else {
            hosting.additionalSafeAreaInsets.bottom = .zero
        }
        if disabledSafeAreaInsets.contains(.right) {
            if (windowSafeAreaInsets?.right ?? 0) > (topVCViewSafeAreaInsets?.right ?? 0) {
                hosting.additionalSafeAreaInsets.right = -(windowSafeAreaInsets?.right ?? 0)
            } else {
                hosting.additionalSafeAreaInsets.right = -(topVCViewSafeAreaInsets?.right ?? 0)
            }
        } else {
            hosting.additionalSafeAreaInsets.right = .zero
        }
        if disabledSafeAreaInsets.contains(.left) {
            if (windowSafeAreaInsets?.left ?? 0) > (topVCViewSafeAreaInsets?.left ?? 0) {
                hosting.additionalSafeAreaInsets.left = -(windowSafeAreaInsets?.left ?? 0)
            } else {
                hosting.additionalSafeAreaInsets.left = -(topVCViewSafeAreaInsets?.left ?? 0)
            }
        } else {
            hosting.additionalSafeAreaInsets.left = .zero
        }
    }
    
    func configureUI() {
        UIView.performWithoutAnimation {
            backgroundColor = .clear
            hostingView.removeFromSuperview()
            hosting = UIHostingController<SwiftUIWrapperView>(rootView: SwiftUIWrapperView(viewModel: swiftUIWrapperModel))
            addSubview(hostingView)
            setGreatestSafeAreaInsets()
            hosting.view.layer.shouldRasterize = swiftUIWrapperModel?.needRasterize ?? true
            hosting.view.layer.rasterizationScale = UIScreen.main.scale
            hostingView.insetsLayoutMarginsFromSafeArea = false
            hostingView.preservesSuperviewLayoutMargins = false
            if needConstraintLayout {
                hostingView.fillSuperview()
                hostingViewConstraintLayouted = true
            } else {
                hostingView.frame = bounds
                hostingViewConstraintLayouted = false
            }
            swipeCoordinator.addSwipes()
        }
    }
    
    public func animateSwipe(direction: SwipeType,
                             isOpen: Bool,
                             swipeWidth: CGFloat?,
                             initialVel: CGFloat?,
                             completion: (() -> Void)?) {
        swipeCoordinator.animateSwipe(direction: direction,
                                      isOpen: isOpen,
                                      swipeWidth: swipeWidth,
                                      initialVel: initialVel,
                                      completion: completion)
    }
        
    public override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        configureUI()
        backgroundColor = .clear
        hosting.rootView.viewModel = swiftUIWrapperModel
        swipeCoordinator.addSwipes()
    }
    
    public override func systemLayoutSizeFitting(_ targetSize: CGSize,
                                                 withHorizontalFittingPriority horizontalFittingPriority: UILayoutPriority,
                                                 verticalFittingPriority: UILayoutPriority) -> CGSize {
        super.systemLayoutSizeFitting(targetSize,
                                      withHorizontalFittingPriority: horizontalFittingPriority,
                                      verticalFittingPriority: verticalFittingPriority)
        frame.size = targetSize
        hostingView.frame = bounds
        var selfSize = hostingView.systemLayoutSizeFitting(targetSize,
                                                           withHorizontalFittingPriority: horizontalFittingPriority,
                                                           verticalFittingPriority: verticalFittingPriority)
        if let size = wrapperSize {
            switch size.width {
            case .absolute(let value): selfSize.width = value
            case .inherit:
                if horizontalFittingPriority == .required { selfSize.width = targetSize.width }
            case .selfSized: break
            }
            switch size.height {
            case .absolute(let value): selfSize.height = value
            case .inherit:
                if verticalFittingPriority == .required { selfSize.height = targetSize.height }
            case .selfSized: break
            }
        }
        return selfSize
    }
    
    public func configure(with data: ViewModelWithViewClass?) {
        guard let data = data as? SwiftUIWrapper<Content> else { return }
        swipeCoordinator.configure(with: data)
        layer.shouldRasterize = data.needRasterize
        hosting.view.layer.shouldRasterize = data.needRasterize
        self.wrapperSize = data.size
        self._needUserInteraction = data.interactive && (data.rightSwipeViews == nil)
        if disabledSafeAreaInsets != data.disabledSafeAreaInsets {
            self.disabledSafeAreaInsets = data.disabledSafeAreaInsets
            configureUI()
        }
        self.swiftUIWrapperModel = data
        self.hostingView.needToFixSwiftUIWrapperInFormView = data.iqKeyboardManagerFix
        self.hosting.rootView.viewModel = data
        self.onAppearClosure = data.onAppearClosure
        self.onDissappearClosure = data.onDissappearClosure
    }
        
    public func onAppear(with formView: FibGrid?) {
        onAppearClosure?(self)
    }
    
    public func onDissappear(with formView: FibGrid?) {
        onDissappearClosure?(self)
    }
    
}
