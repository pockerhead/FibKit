//
//  FibCell.swift
//  SmartStaff
//
//  Created artem on 24.04.2020.
//  Copyright Â© 2020 DIT. All rights reserved.
//
//  Template generated by Balashov Artem @pockerhead
//

import UIKit

open class SqueezeCell: UICollectionViewCell {

    var feedback = UISelectionFeedbackGenerator()
    open var needUserInteraction: Bool { false }
    open var squeezeUpDuration: TimeInterval = 0.1
    open var squeezeDownDuration: TimeInterval = 0.2
    open var squeezeDownScale: CGFloat = 0.95

    // MARK: - Touches
    override open func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesBegan(touches, with: event)
        guard needUserInteraction, isUserInteractionEnabled else { return }
        UIView.animate(withDuration: squeezeDownDuration) {
            self.transform = CGAffineTransform(scaleX: self.squeezeDownScale, y: self.squeezeDownScale)
        }
    }

    override open func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesEnded(touches, with: event)
        guard needUserInteraction, isUserInteractionEnabled else { return }
        DispatchQueue.main.async {
            UISelectionFeedbackGenerator().selectionChanged()
        }
        UIView.animate(withDuration: squeezeUpDuration) {
            self.transform = .identity
        }
    }
    override open func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
        super.touchesCancelled(touches, with: event)
        guard needUserInteraction, isUserInteractionEnabled else { return }
        UIView.animate(withDuration: squeezeUpDuration) {
            self.transform = .identity
        }
    }
}


open class RoundedCell: SqueezeCell {
    
    open var isForceDisableRoundCorners: Bool {
        false
    }

    public required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    public override init(frame: CGRect) {
        super.init(frame: frame)
        setup()
    }

    private func setup() {
        self.layer.applySketchShadow()
        layer.shouldRasterize = true
        layer.rasterizationScale = UIScreen.main.scale
        self.contentView.clipsToBounds = true
        self.clipsToBounds = true
        self.layer.masksToBounds = false
        if !isForceDisableRoundCorners {
            self.contentView.layer.cornerRadius = 12
            self.layer.cornerRadius = 12
        }
    }

    open override func layoutSubviews() {
        super.layoutSubviews()
        self.layer.applySketchShadow()
    }
}


import SkeletonView
import UIKit
import VisualEffectView

public final class FibCell: RoundedCell, StickyHeaderView {

    // MARK: Outlets

    // MARK: Properties
    let formView = FibGrid()
    
    public struct Appearance {
        public static var blurViewColorTint = UIColor.systemBackground
        public static var backgroundColor = UIColor.systemBackground
        public static var gridBackgroundColor = UIColor.tertiarySystemBackground
    }

    var _needUserInteraction: Bool = false
    override public  var needUserInteraction: Bool { _needUserInteraction }
    private var _additionalBackgroundColor: UIColor?
    public var needRound: Bool = true
    var needBlurBackground = false
    private lazy var blurView: VisualEffectView = {
        let view = VisualEffectView()
        view.colorTint = Appearance.blurViewColorTint
        view.colorTintAlpha = 0.2
        view.blurRadius = 16
        return view
    }()
    fileprivate var getSize: ((CGSize) -> Void)?

    // MARK: Initialization

    override public  func awakeFromNib() {
        super.awakeFromNib()
        configureUI()
    }

    override init(frame: CGRect) {
        super.init(frame: frame)
        configureUI()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        configureUI()
    }

    // MARK: UI Configuration

    private func configureUI() {
        contentView.addSubview(formView)
        contentView.layer.cornerRadius = 12
        contentView.clipsToBounds = true
        formView.fillSuperview()
        formView.isScrollEnabled = false
        formView.animated = false
        formView.layer.cornerRadius = 12
        formView.clipsToBounds = true
        formView.layer.masksToBounds = true
        contentView.addSubview(blurView)
        contentView.sendSubviewToBack(blurView)
        blurView.fillSuperview()
        blurView.layer.masksToBounds = true
        blurView.clipsToBounds = true
        blurView.isHidden = !needBlurBackground
        makeSkeletonable()
    }

    public override func layoutSubviews() {
        super.layoutSubviews()
        if needRound {
            layer.cornerRadius = 12
            contentView.layer.cornerRadius = 12
            formView.layer.cornerRadius = 12
        } else {
            self.layer.clearShadow()
            layer.cornerRadius = 0
            contentView.layer.cornerRadius = 0
            formView.layer.cornerRadius = 0
        }
    }
    
    public func sizeChanged(size: CGSize, initialHeight: CGFloat, maxHeight: CGFloat?, minHeight: CGFloat?) {
        UIView.performWithoutAnimation {
            let clampedChangedHeight = size.height
                .clamp(minHeight ?? -.greatestFiniteMagnitude, maxHeight ?? .greatestFiniteMagnitude)
            let diff = clampedChangedHeight - initialHeight
            formView.setContentOffset(.init(x: formView.contentOffset.x, y: -diff), animated: false)
        }
    }

}

// MARK: ViewModelConfigurable

extension FibCell: FibViewHeader {

    /// View Model for FormViewCell, contains default parameters of ViewModelWithViewClass, and sections for inner FormView
    public final class ViewModel: FibViewHeaderViewModel {

        /// Sections for inner FormView, work equally that default FormView
        public var sections: [GridSection]
        public var sizeHash: String?
        public var storedId: String?
        public var storedSections: [GridSection] = []
        public var size: NilSize?
        public var backgroundColor: UIColor?
        public var atTop: Bool = false
        public var needRound: Bool = true
        public var delay: TimeInterval?
        public var needBlurBackground = false
        public private(set) var allowedStretchDirections: Set<StretchDirection> = []
        /// if needs squeeze animation
        public var needUserInteraction: Bool = false
        public private(set) var minHeight: CGFloat? = 0
        public private(set) var getSize: ((CGSize) -> Void)?

        public func viewClass() -> ViewModelConfigurable.Type {
            FibCell.self
        }

        /// Inits ViewModel with declarative sections
        /// - Parameter sections: Sections for inner FormView
        public init(sections: [GridSection]) {
            self.sections = sections
        }

        /// Inits ViewModel with declarative sections
        /// - Parameter sections: Sections for inner FormView
        public init(@SectionBuilder _ sections: () -> [GridSection]) {
            self.sections = sections()
        }

        public func allowedStretchDirections(_ allowedStretchDirections: Set<StretchDirection>) -> Self {
            self.allowedStretchDirections = allowedStretchDirections
            return self
        }
        
        public func needBlur(_ need: Bool) -> Self {
            self.needBlurBackground = need
            return self
        }

        public func needRound(_ needRound: Bool) -> Self {
            self.needRound = needRound
            return self
        }

        public func delay(_ delay: TimeInterval?) -> Self {
            self.delay = delay
            return self
        }

        public func backgroundColor(_ color: UIColor) -> Self {
            self.backgroundColor = color
            return self
        }

        /// SizeHash modifier
        /// - Parameter hash: sizeHash
        /// - Returns: self
        public func sizeHash(_ hash: String) -> Self {
            self.sizeHash = hash
            return self
        }

        /// Id modifier
        /// - Parameter id: unique id
        /// - Returns: self
        public func id(_ id: String) -> Self {
            self.storedId = id
            return self
        }

        public func size(_ size: NilSize) -> Self {
            self.size = size
            return self
        }

        public func atTop(_ atTop: Bool) -> Self {
            self.atTop = atTop
            return self
        }

        /// modifier that allows cell interact to user touches
        /// - Parameter interaction: need interaction
        /// - Returns: self
        public func needUserInteraction(_ interaction: Bool) -> Self {
            self.needUserInteraction = interaction
            return self
        }
        
        public func getSize(_ closure: ((CGSize) -> Void)?) -> Self {
            self.getSize = closure
            return self
        }
        
        public func minHeight(_ height: CGFloat) -> Self {
            self.minHeight = height
            return self
        }
    }

    public func configure(with data: ViewModelWithViewClass?) {
        guard let data = data as? ViewModel else {
            self.showAnimatedGradientSkeleton(usingGradient: .mainGradient)
            return
        }
        hideSkeleton()
        self.getSize = data.getSize
        needRound = data.needRound
        formView.sections.forEach { $0.animator = nil }
        formView.isEmbedCollection = true
        _needUserInteraction = data.needUserInteraction
        layer.cornerRadius = 12
        if let additionalBackground = data.backgroundColor {
            self._additionalBackgroundColor = additionalBackground
            formView.backgroundColor = _additionalBackgroundColor ?? Appearance.gridBackgroundColor
        }
        blurView.isHidden = !data.needBlurBackground
        if let delayInterval = data.delay {
            delay(delayInterval, closure: ({[weak self] in
                self?.formView.sections = data.sections
            }))
        } else {
            formView.sections = data.sections
        }
    }

    public func sizeWith(_ targetSize: CGSize, data: ViewModelWithViewClass?) -> CGSize? {
        guard let data = data as? ViewModel else { return nil }
        if let size = data.size {
            let width = size.width ?? targetSize.width
            let height = size.height ?? targetSize.height
            return CGSize(width: width, height: height)
        }
        frame.size.width = targetSize.width == 0 ? UIScreen.main.bounds.width : targetSize.width
        configure(with: data.delay(nil))
        layoutIfNeeded()
        formView.layoutIfNeeded()
        delay {[weak self] in
            guard let self = self else { return }
            self.getSize?(self.formView.contentSize)
        }
        return self.formView.contentSize
    }
    
    public override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
            backgroundColor = .clear
        formView.backgroundColor = _additionalBackgroundColor ?? Appearance.gridBackgroundColor
        blurView.colorTint = Appearance.blurViewColorTint
    }
}

// MARK: Themeable

public struct NilSize {

    @available(*, deprecated, message: "Use initializer with parameters instead")
    public init() {
        width = nil
        height = nil
    }

    public init(width: CGFloat? = nil,
                height: CGFloat? = nil) {
        self.width = width
        self.height = height
    }

    public let width: CGFloat?
    public let height: CGFloat?
}
